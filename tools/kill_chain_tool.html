<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Kill Chain Probability Modeller</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
:root{--primary:#2563eb;--success:#10b981;--danger:#ef4444;--warning:#f59e0b;--gray:#6b7280;--light:#f3f4f6;--dark:#1f2937;}
*{margin:0;padding:0;box-sizing:border-box;}
body{font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;background:#f9fafb;color:var(--dark);line-height:1.6;}
.container{max-width:1200px;margin:auto;padding:1rem;}
header{text-align:center;margin-bottom:2rem;padding:1.5rem 0;background:white;box-shadow:0 1px 3px rgba(0,0,0,.1);border-radius:8px;}
h1{color:var(--primary);margin-bottom:.5rem;}
.subtitle{color:var(--gray);font-size:1.1rem;}
.controls{display:flex;gap:1rem;margin-bottom:1.5rem;flex-wrap:wrap;justify-content:center;align-items:center;}
button{padding:.65rem 1.25rem;border:none;border-radius:6px;font-weight:600;cursor:pointer;transition:all .2s;display:inline-flex;align-items:center;gap:.5rem;}
.btn-primary{background:var(--primary);color:white;}
.btn-primary:hover{background:#1d4ed8;transform:translateY(-1px);}
.btn-success{background:var(--success);color:white;}
.btn-success:hover{background:#059669;}
.btn-danger{background:var(--danger);color:white;}
.btn-danger:hover{background:#dc2626;}
.btn-warning{background:var(--warning);color:white;}
.btn-warning:hover{background:#d97706;}
.btn-secondary{background:#6b7280;color:white;}
.btn-secondary:hover{background:#4b5563;}
/* ---- DROPDOWN ---- */
.dropdown-container{position:relative;display:inline-block;}
.dropdown-toggle{
    padding:.65rem 1.25rem;
    background:#6b7280;color:white;
    border:none;border-radius:6px;
    cursor:pointer;font-weight:600;
    display:flex;align-items:center;gap:.5rem;
}
.dropdown-toggle::after{
    content:" ▼";font-size:.9rem;margin-left:.25rem;
}
.dropdown-menu{
    position:absolute;top:100%;left:0;
    background:white;min-width:300px;max-height:320px;overflow-y:auto;
    box-shadow:0 4px 12px rgba(0,0,0,.15);border-radius:6px;
    z-index:1000;display:none;opacity:0;transform:translateY(-10px);transition:all .2s ease;
}
.dropdown-menu.show{display:block;opacity:1;transform:translateY(0);}
.dropdown-item{
    padding:.75rem 1rem;cursor:pointer;border:none;background:none;
    width:100%;text-align:left;transition:background .2s;font-size:.95rem;
}
.dropdown-item:hover{background:#f0f9ff;color:var(--primary);}
/* ---- REST OF STYLES (unchanged) ---- */
.kill-chain{display:flex;flex-direction:column;gap:1rem;margin-bottom:2rem;}
.stage{background:white;border-radius:8px;padding:1.25rem;box-shadow:0 1px 3px rgba(0,0,0,.1);border-left:5px solid var(--primary);transition:all .3s;position:relative;}
.stage:hover{box-shadow:0 4px 8px rgba(0,0,0,.12);transform:translateY(-2px);}
.stage-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem;}
.stage-index{background:var(--primary);color:white;width:28px;height:28px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:.9rem;}
.stage-actions{display:flex;gap:.5rem;}
.stage-actions button{padding:.4rem .8rem;font-size:.85rem;}
.form-group{margin-bottom:1rem;}
label{display:block;margin-bottom:.5rem;font-weight:500;color:var(--gray);}
input[type=text],select,input[type=number]{width:100%;padding:.65rem;border:1px solid #d1d5db;border-radius:6px;font-size:1rem;transition:border .2s;}
input:focus,select:focus{outline:none;border-color:var(--primary);box-shadow:0 0 0 3px rgba(37,99,235,.1);}
.probability-input{display:flex;align-items:center;gap:1rem;}
.probability-value{font-weight:bold;color:var(--primary);min-width:60px;text-align:right;}
.probability-bar{flex:1;height:8px;background:#e5e7eb;border-radius:4px;overflow:hidden;}
.probability-fill{height:100%;background:var(--primary);border-radius:4px;transition:width .3s ease;position:relative;}
.probability-fill::after{content:'';position:absolute;top:0;right:0;height:100%;width:20px;background:linear-gradient(90deg,transparent,rgba(255,255,255,.3));}
.cumulative-prob{margin-top:.75rem;padding:.75rem;background:#f0f9ff;border-radius:6px;font-weight:600;color:var(--primary);text-align:center;font-size:1.1rem;}
.results{background:white;padding:1.5rem;border-radius:8px;box-shadow:0 1px 3px rgba(0,0,0,.1);margin-bottom:2rem;}
.chart-container{position:relative;height:300px;margin-top:1.5rem;}
.summary-stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:1rem;margin-top:1.5rem;}
.stat-card{background:#f8fafc;padding:1rem;border-radius:8px;text-align:center;border:1px solid #e2e8f0;}
.stat-value{font-size:1.5rem;font-weight:bold;color:var(--primary);}
.stat-label{color:var(--gray);font-size:.9rem;margin-top:.25rem;}
.empty-state{text-align:center;padding:3rem 1rem;color:var(--gray);}
.empty-state svg{width:80px;height:80px;margin-bottom:1rem;opacity:.5;}
.file-input-wrapper{position:relative;overflow:hidden;display:inline-block;}
.file-input-wrapper input[type=file]{position:absolute;left:-9999px;}
.file-input-label{display:inline-flex;align-items:center;gap:.5rem;padding:.65rem 1.25rem;background:#6b7280;color:white;border-radius:6px;cursor:pointer;font-weight:600;transition:all .2s;}
.file-input-label:hover{background:#4b5563;}
.drag-handle{cursor:move;color:var(--gray);margin-right:.5rem;}
.stage.dragging{opacity:.5;transform:rotate(5deg);}
@media(max-width:768px){
    .stage-header{flex-direction:column;align-items:flex-start;gap:.75rem;}
    .stage-actions{align-self:flex-end;}
    .probability-input{flex-direction:column;align-items:stretch;}
    .probability-value{text-align:left;}
}
</style>
</head>
<body>
<div class="container">
<header>
    <h1>Kill Chain Probability Modeller</h1>
    <p class="subtitle">Model cyber attack kill chains with stage-by-stage success probabilities</p>
</header>

<div class="controls">
    <button id="add-stage" class="btn-primary">Add Stage</button>

    <!-- TEMPLATE DROPDOWN -->
    <div class="dropdown-container">
        <button id="load-template" class="btn-secondary dropdown-toggle">Load Template</button>
        <div id="template-menu" class="dropdown-menu"></div>
    </div>

    <button id="calculate" class="btn-success">Calculate Chain</button>
    <button id="export-chain" class="btn-warning">Export Chain</button>
    <div class="file-input-wrapper">
        <input type="file" id="import-chain-input" accept=".json">
        <label for="import-chain-input" class="file-input-label">Import Chain</label>
    </div>
    <button id="clear-all" class="btn-danger">Clear All</button>
</div>

<div id="kill-chain" class="kill-chain">
    <div class="empty-state">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6-4h6m2 5a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
        <h3>No stages yet</h3>
        <p>Click "Add Stage" to start building your kill chain</p>
    </div>
</div>

<div id="results" class="results" style="display:none;">
    <h2 style="margin-bottom:1rem;color:var(--primary);">Overall Attack Success Probability</h2>
    <div id="overall-probability" class="cumulative-prob" style="font-size:2rem;padding:1.5rem;">0.00%</div>
    <div class="chart-container"><canvas id="probabilityChart"></canvas></div>
    <div class="summary-stats">
        <div class="stat-card"><div id="total-stages" class="stat-value">0</div><div class="stat-label">Total Stages</div></div>
        <div class="stat-card"><div id="avg-probability" class="stat-value">0.00%</div><div class="stat-label">Average Stage Success</div></div>
        <div class="stat-card"><div id="weakest-stage" class="stat-value">-</div><div class="stat-label">Weakest Link</div></div>
        <div class="stat-card"><div id="risk-reduction" class="stat-value">0.00%</div><div class="stat-label">Risk Reduction vs. 100%</div></div>
    </div>
</div>
</div>

<script>
class KillChainModeller{
    constructor(){
        this.stages=[];this.chart=null;this.draggedElement=null;
        this.mitreTactics=[
            'Reconnaissance (TA0043)','Resource Development (TA0042)','Initial Access (TA0001)','Execution (TA0002)',
            'Persistence (TA0003)','Privilege Escalation (TA0004)','Defense Evasion (TA0005)','Credential Access (TA0006)',
            'Discovery (TA0007)','Lateral Movement (TA0008)','Collection (TA0009)','Command and Control (TA0011)',
            'Exfiltration (TA0010)','Impact (TA0040)'
        ];
        this.templates={
            'Lockheed Martin Cyber Kill Chain':[
                {name:'Reconnaissance',probability:95,tactic:'Reconnaissance (TA0043)'},
                {name:'Weaponization',probability:85,tactic:'Resource Development (TA0042)'},
                {name:'Delivery',probability:70,tactic:'Initial Access (TA0001)'},
                {name:'Exploitation',probability:60,tactic:'Execution (TA0002)'},
                {name:'Installation',probability:55,tactic:'Persistence (TA0003)'},
                {name:'Command and Control',probability:80,tactic:'Command and Control (TA0011)'},
                {name:'Actions on Objectives',probability:75,tactic:'Impact (TA0040)'}
            ],
            'Phishing to Credential Stealer (MFA + CA Bypass)':[
                {name:'Email Delivered (Not Blocked by SEG/ATP)',probability:85,tactic:'Initial Access (TA0001)'},
                {name:'User Opens Email',probability:70,tactic:'Initial Access (TA0001)'},
                {name:'User Clicks Malicious Link',probability:60,tactic:'Initial Access (TA0001)'},
                {name:'Phishing Site Not Blocked (PDNS, Safe Browsing, Web Proxy)',probability:75,tactic:'Initial Access (TA0001)'},
                {name:'User Enters Credentials on Fake Site',probability:55,tactic:'Credential Access (TA0006)'},
                {name:'MFA Not Enabled (or Bypassed via MFA Fatigue/Prompt Bombing)',probability:40,tactic:'Credential Access (TA0006)'},
                {name:"Conditional Access Doesn't Block Login (Location, Device, Risk)",probability:65,tactic:'Persistence (TA0003)'},
                {name:'Adversary Successfully Logs In (Account Takeover)',probability:90,tactic:'Persistence (TA0003)'}
            ]
        };
        console.log('Initializing Kill Chain Modeller...');
        this.initEventListeners();
        this.loadFromStorage();
        this.populateTemplateMenu();
        console.log('Initialization complete.');
    }

    initEventListeners(){
        console.log('Setting up event listeners...');
        const addBtn = document.getElementById('add-stage');
        if (addBtn) {
            addBtn.addEventListener('click', () => {
                console.log('Add Stage clicked');
                this.addStage();
            });
        } else {
            console.error('Add Stage button not found');
        }

        const calcBtn = document.getElementById('calculate');
        if (calcBtn) calcBtn.addEventListener('click', () => this.calculateChain());

        const clearBtn = document.getElementById('clear-all');
        if (clearBtn) clearBtn.addEventListener('click', () => this.clearAll());

        const exportBtn = document.getElementById('export-chain');
        if (exportBtn) exportBtn.addEventListener('click', () => this.exportChain());

        const importInput = document.getElementById('import-chain-input');
        if (importInput) importInput.addEventListener('change', e => this.importChain(e));

        const toggle = document.getElementById('load-template');
        if (toggle) {
            toggle.addEventListener('click', e => {
                console.log('Load Template clicked');
                e.stopPropagation();
                this.toggleTemplateMenu();
            });
        } else {
            console.error('Load Template button not found');
        }

        document.addEventListener('click', e => {
            if (!e.target.closest('.dropdown-container')) this.hideTemplateMenu();
        });
        const templateMenu = document.getElementById('template-menu');
        if (templateMenu) templateMenu.addEventListener('click', e => e.stopPropagation());

        const cont = document.getElementById('kill-chain');
        if (cont) {
            cont.addEventListener('dragstart', e => this.handleDragStart(e));
            cont.addEventListener('dragover', e => e.preventDefault());
            cont.addEventListener('drop', e => this.handleDrop(e));
            cont.addEventListener('dragend', () => this.handleDragEnd());
        }
        console.log('Event listeners set up.');
    }

    toggleTemplateMenu(){
        console.log('Toggling template menu');
        const menu = document.getElementById('template-menu');
        if (menu) {
            menu.classList.toggle('show');
        }
    }
    hideTemplateMenu(){
        console.log('Hiding template menu');
        const menu = document.getElementById('template-menu');
        if (menu) menu.classList.remove('show');
    }

    populateTemplateMenu(){
        console.log('Populating template menu');
        const menu = document.getElementById('template-menu');
        if (!menu) {
            console.error('Template menu not found');
            return;
        }
        menu.innerHTML = '';
        Object.keys(this.templates).forEach(name => {
            const btn = document.createElement('button');
            btn.className = 'dropdown-item';
            btn.textContent = name;
            btn.addEventListener('click', () => {
                console.log(`Loading template: ${name}`);
                this.loadTemplate(name);
                this.hideTemplateMenu();
            });
            menu.appendChild(btn);
        });
        console.log('Template menu populated');
    }

    loadTemplate(name){
        const tmpl = this.templates[name];
        if (!tmpl) {
            console.error(`Template ${name} not found`);
            return;
        }
        if (this.stages.length && !confirm('Loading a template will clear current stages. Continue?')) return;
        this.clearAll(true);
        tmpl.forEach(s => this.addStage(s.name, s.probability, s.tactic));
        alert(`Loaded: ${name}`);
    }

    addStage(name = '', probability = 50, tactic = ''){
        console.log('Adding new stage');
        const stage = {
            id: Date.now() + Math.random(),
            name: name || `Stage ${this.stages.length + 1}`,
            probability: Math.max(0, Math.min(100, probability)),
            tactic
        };
        this.stages.push(stage);
        this.renderStage(stage);
        this.updateEmptyState();
        this.saveToStorage();
        console.log(`Stage added: ${stage.name}`);
    }

    renderStage(stage){
        const index = this.stages.indexOf(stage) + 1;
        const html = `
            <div class="stage" data-id="${stage.id}" draggable="true">
                <div class="stage-header">
                    <div style="display:flex;align-items:center;gap:.5rem;">
                        <span class="drag-handle">⋮⋮</span>
                        <div class="stage-index">${index}</div>
                        <input type="text" class="stage-title-input" value="${stage.name}" placeholder="Enter stage name">
                    </div>
                    <div class="stage-actions">
                        <button class="btn-primary duplicate-stage">Duplicate</button>
                        <button class="btn-danger delete-stage">Delete</button>
                    </div>
                </div>
                <div class="form-group">
                    <label>MITRE ATT&CK Tactic (Optional):</label>
                    <select class="tactic-select">
                        <option value="">No Tactic</option>
                        ${this.mitreTactics.map(t => `<option value="${t}" ${stage.tactic === t ? 'selected' : ''}>${t}</option>`).join('')}
                    </select>
                </div>
                <div class="form-group">
                    <label>Success Probability: <span class="probability-value">${stage.probability.toFixed(1)}%</span></label>
                    <div class="probability-input">
                        <input type="range" class="probability-slider" min="0" max="100" step="0.1" value="${stage.probability}">
                        <div class="probability-bar"><div class="probability-fill" style="width:${stage.probability}%"></div></div>
                    </div>
                </div>
                <div class="cumulative-prob">Cumulative Success: <span class="cumulative-value">Calculating...</span></div>
            </div>`;
        const container = document.getElementById('kill-chain');
        const div = document.createElement('div');
        div.innerHTML = html;
        const el = div.firstElementChild;
        const empty = container.querySelector('.empty-state');
        if (empty) {
            container.insertBefore(el, empty);
        } else {
            container.appendChild(el);
        }

        // Attach event listeners
        const slider = el.querySelector('.probability-slider');
        const fill = el.querySelector('.probability-fill');
        const val = el.querySelector('.probability-value');
        const title = el.querySelector('.stage-title-input');
        const tacticSelect = el.querySelector('.tactic-select');
        const cum = el.querySelector('.cumulative-value');
        const deleteBtn = el.querySelector('.delete-stage');
        const duplicateBtn = el.querySelector('.duplicate-stage');

        if (slider) {
            slider.addEventListener('input', e => {
                const p = +e.target.value;
                stage.probability = p;
                fill.style.width = p + '%';
                val.textContent = p.toFixed(1) + '%';
                this.saveToStorage();
                this.updateCumulative(stage, cum);
            });
        }
        if (title) {
            title.addEventListener('input', e => {
                stage.name = e.target.value.trim() || `Stage ${this.stages.indexOf(stage) + 1}`;
                this.saveToStorage();
            });
        }
        if (tacticSelect) {
            tacticSelect.addEventListener('change', e => {
                stage.tactic = e.target.value;
                this.saveToStorage();
            });
        }
        if (deleteBtn) {
            deleteBtn.addEventListener('click', () => this.deleteStage(stage.id));
        }
        if (duplicateBtn) {
            duplicateBtn.addEventListener('click', () => this.addStage(stage.name + ' (Copy)', stage.probability, stage.tactic));
        }
        this.updateCumulative(stage, cum);
    }

    updateCumulative(stage, el) {
        const i = this.stages.indexOf(stage);
        let c = 1;
        for (let j = 0; j <= i; j++) {
            c *= this.stages[j].probability / 100;
        }
        if (el) el.textContent = (c * 100).toFixed(3) + '%';
    }

    updateAllCumulatives(){
        document.querySelectorAll('.stage').forEach((el, i) => {
            const cum = el.querySelector('.cumulative-value');
            let c = 1;
            for (let j = 0; j <= i; j++) {
                c *= this.stages[j].probability / 100;
            }
            if (cum) cum.textContent = (c * 100).toFixed(3) + '%';
        });
    }

    deleteStage(id){
        this.stages = this.stages.filter(s => s.id !== id);
        const el = document.querySelector(`[data-id="${id}"]`);
        if (el) el.remove();
        this.updateStageIndices();
        this.updateEmptyState();
        this.saveToStorage();
    }

    updateStageIndices(){
        document.querySelectorAll('.stage').forEach((el, i) => {
            const indexEl = el.querySelector('.stage-index');
            if (indexEl) indexEl.textContent = i + 1;
            const s = this.stages.find(st => st.id == el.dataset.id);
            if (s) {
                const inp = el.querySelector('.stage-title-input');
                if (inp && !inp.value.trim()) {
                    inp.value = `Stage ${i + 1}`;
                    s.name = inp.value;
                }
            }
        });
        this.updateAllCumulatives();
    }

    calculateChain(){
        if (!this.stages.length) {
            alert('Add at least one stage first.');
            return;
        }
        this.updateAllCumulatives();
        const overall = this.stages.reduce((a, s) => a * (s.probability / 100), 1) * 100;
        const overallEl = document.getElementById('overall-probability');
        if (overallEl) overallEl.textContent = overall.toFixed(4) + '%';
        const totalEl = document.getElementById('total-stages');
        if (totalEl) totalEl.textContent = this.stages.length;
        const avg = this.stages.reduce((s, v) => s + v.probability, 0) / this.stages.length;
        const avgEl = document.getElementById('avg-probability');
        if (avgEl) avgEl.textContent = avg.toFixed(1) + '%';
        const weak = this.stages.reduce((m, s) => s.probability < m.probability ? s : m, this.stages[0] || { probability: 0, name: '-' });
        const weakEl = document.getElementById('weakest-stage');
        if (weakEl) weakEl.textContent = `${weak.name} (${weak.probability.toFixed(1)}%)`;
        const riskEl = document.getElementById('risk-reduction');
        if (riskEl) riskEl.textContent = (100 - overall).toFixed(4) + '%';
        const results = document.getElementById('results');
        if (results) results.style.display = 'block';
        this.updateChart();
    }

    updateChart(){
        const canvas = document.getElementById('probabilityChart');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const labels = this.stages.map(s => s.name);
        const stageP = this.stages.map(s => s.probability);
        const cumP = [];
        let c = 1;
        this.stages.forEach(s => {
            c *= s.probability / 100;
            cumP.push(c * 100);
        });
        const data = {
            labels,
            datasets: [
                {
                    label: 'Stage Success Probability (%)',
                    data: stageP,
                    backgroundColor: 'rgba(37,99,235,.6)',
                    borderColor: 'rgba(37,99,235,1)',
                    borderWidth: 2,
                    type: 'bar'
                },
                {
                    label: 'Cumulative Success Probability (%)',
                    data: cumP,
                    backgroundColor: 'rgba(16,185,129,.1)',
                    borderColor: 'rgba(16,185,129,1)',
                    borderWidth: 3,
                    type: 'line',
                    tension: 0.4,
                    pointBackgroundColor: 'rgba(16,185,129,1)',
                    pointRadius: 5
                }
            ]
        };
        if (this.chart) this.chart.destroy();
        this.chart = new Chart(ctx, {
            type: 'bar',
            data,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Kill Chain Probability Analysis',
                        font: { size: 16, weight: 'bold' }
                    },
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(3)}%`
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        title: { display: true, text: 'Probability (%)' }
                    }
                }
            }
        });
    }

    clearAll(force = false){
        if (!force && this.stages.length && !confirm('Remove all stages?')) return;
        this.stages = [];
        const killChain = document.getElementById('kill-chain');
        if (killChain) {
            killChain.innerHTML = `
                <div class="empty-state">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6-4h6m2 5a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <h3>No stages yet</h3>
                    <p>Click "Add Stage" to start building your kill chain</p>
                </div>`;
        }
        const results = document.getElementById('results');
        if (results) results.style.display = 'none';
        if (this.chart) this.chart.destroy();
        localStorage.removeItem('killChainStages');
    }

    updateEmptyState(){
        const cont = document.getElementById('kill-chain');
        if (!cont) return;
        const has = cont.querySelector('.stage');
        const empty = cont.querySelector('.empty-state');
        if (!has && !empty) {
            const e = document.createElement('div');
            e.className = 'empty-state';
            e.innerHTML = `<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6-4h6m2 5a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><h3>No stages yet</h3><p>Click "Add Stage" to start building your kill chain</p>`;
            cont.appendChild(e);
        } else if (has && empty) {
            empty.remove();
        }
    }

    exportChain(){
        if (!this.stages.length) {
            alert('Add stages first.');
            return;
        }
        const data = {
            name: "Kill Chain Model",
            exportedAt: new Date().toISOString(),
            version: "1.0",
            stages: this.stages.map(s => ({ name: s.name, probability: s.probability, tactic: s.tactic }))
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `kill-chain-${new Date().toISOString().slice(0, 10)}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

    importChain(e){
        const file = e.target.files[0];
        if (!file) return;
        if (!file.name.endsWith('.json')) {
            alert('Select a .json file.');
            return;
        }
        const r = new FileReader();
        r.onload = ev => {
            try {
                const d = JSON.parse(ev.target.result);
                if (!d.stages || !Array.isArray(d.stages)) throw new Error('Invalid format');
                this.stages = [];
                const killChain = document.getElementById('kill-chain');
                if (killChain) killChain.innerHTML = '';
                d.stages.forEach(s => {
                    if (s.name && typeof s.probability === 'number') {
                        this.addStage(s.name, s.probability, s.tactic || '');
                    }
                });
                this.updateEmptyState();
                this.saveToStorage();
                alert(`Imported ${this.stages.length} stage(s).`);
            } catch (err) {
                alert('Invalid JSON.');
                console.error(err);
            }
        };
        r.readAsText(file);
        e.target.value = '';
    }

    handleDragStart(e){
        const el = e.target.closest('.stage');
        if (el) {
            this.draggedElement = el;
            el.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }
    }
    handleDrop(e){
        e.preventDefault();
        if (!this.draggedElement) return;
        const target = e.target.closest('.stage');
        const cont = document.getElementById('kill-chain');
        if (!cont || !target || target === this.draggedElement) return;
        const all = [...cont.querySelectorAll('.stage')];
        const from = all.indexOf(this.draggedElement);
        const to = all.indexOf(target);
        if (from < to) {
            target.after(this.draggedElement);
        } else {
            target.before(this.draggedElement);
        }
        const s = this.stages[from];
        this.stages.splice(from, 1);
        this.stages.splice(to, 0, s);
        this.updateStageIndices();
        this.saveToStorage();
    }
    handleDragEnd(){
        if (this.draggedElement) {
            this.draggedElement.classList.remove('dragging');
            this.draggedElement = null;
        }
    }

    saveToStorage(){
        localStorage.setItem('killChainStages', JSON.stringify(this.stages));
    }
    loadFromStorage(){
        const s = localStorage.getItem('killChainStages');
        if (s) {
            try {
                const p = JSON.parse(s);
                if (Array.isArray(p)) {
                    this.stages = p;
                    const killChain = document.getElementById('kill-chain');
                    if (killChain) killChain.innerHTML = '';
                    p.forEach(st => this.renderStage(st));
                    this.updateEmptyState();
                }
            } catch (e) {
                console.error('Failed to load from storage:', e);
            }
        }
    }
}
document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM loaded, starting app');
    new KillChainModeller();
});
</script>
</body>
</html>
