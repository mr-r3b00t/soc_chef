<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZIP → hashcat</title>
    <style>
        body{font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;margin:30px;background:#f9f9fb;color:#333}
        h1{color:#2c3e50}
        .container{max-width:900px;margin:auto;background:#fff;padding:25px;border-radius:10px;box-shadow:0 2px 10px rgba(0,0,0,.1)}
        input[type=file]{margin:15px 0;padding:10px;border:1px solid #ddd;border-radius:5px;width:100%;box-sizing:border-box}
        button{background:#3498db;color:#fff;border:none;padding:12px 24px;font-size:16px;border-radius:5px;cursor:pointer;transition:.3s;margin-right:10px}
        button:hover{background:#2980b9}
        button.copy{background:#27ae60}
        button.copy:hover{background:#219653}
        #output{margin-top:20px;max-height:600px;overflow-y:auto;font-family:'Courier New',monospace;font-size:14px;line-height:1.7}
        .hash-line{display:flex;align-items:flex-start;background:#2c3e50;color:#1abc9c;padding:12px;border-radius:5px;margin-bottom:8px;overflow-x:auto;overflow-y:hidden;min-width:0}
        .hash-text{flex:1;white-space:pre;overflow-x:auto;overflow-y:hidden;min-width:0;padding-right:10px}
        .hash-mode{background:#e74c3c;color:#fff;font-weight:bold;padding:4px 8px;border-radius:4px;margin-right:12px;font-size:12px;min-width:60px;text-align:center}
        .no-hash{background:#f8f9fa;color:#6c757d;padding:15px;border-radius:5px;text-align:center;font-style:italic}
        .info{background:#e8f4fc;padding:12px;border-left:4px solid #3498db;margin:15px 0;font-size:14px}
        .warning{background:#fdf6e3;border-left:4px solid #f39c12}
        .button-group{margin-top:15px}
        .copy-feedback{color:#27ae60;font-weight:bold;margin-left:10px;display:none}
        .legend{display:flex;flex-wrap:wrap;gap:12px;margin:15px 0;font-size:14px}
        .legend-item{display:flex;align-items:center;gap:6px}
        .legend-color{width:16px;height:16px;border-radius:3px}

        /* Smooth scrollbars */
        .hash-line::-webkit-scrollbar,.hash-text::-webkit-scrollbar{height:8px}
        .hash-line::-webkit-scrollbar-track,.hash-text::-webkit-scrollbar-track{background:#1a252f;border-radius:4px}
        .hash-line::-webkit-scrollbar-thumb,.hash-text::-webkit-scrollbar-thumb{background:#1abc9c;border-radius:4px}
    </style>
</head>
<body>
<div class="container">
    <h1>ZIP Hash Extractor for hashcat</h1>
    <p>Extract password hashes from encrypted ZIP files in <strong>hashcat</strong> format.</p>

    <div class="info">
        <strong>Supported:</strong> WinZip AES, PKZIP, SecureZIP AES (128/192/256), PKWARE Strong
    </div>

    <input type="file" id="fileInput" accept=".zip"><br><br>
    <button onclick="processFile()">Extract Hashes</button>

    <div class="button-group" id="copyButtonContainer" style="display:none">
        <button class="copy" onclick="copyToClipboard()">Copy Hashes Only</button>
        <span class="copy-feedback" id="copyFeedback">Copied!</span>
    </div>

    <div class="legend">
        <div class="legend-item"><div class="legend-color" style="background:#e74c3c"></div><span><strong>13600</strong> — WinZip AES</span></div>
        <div class="legend-item"><div class="legend-color" style="background:#3498db"></div><span><strong>17200</strong> — PKZIP (Compressed)</span></div>
        <div class="legend-item"><div class="legend-color" style="background:#9b59b6"></div><span><strong>17210</strong> — PKZIP (Uncompressed)</span></div>
        <div class="legend-item"><div class="legend-color" style="background:#1abc9c"></div><span><strong>23001</strong> — SecureZIP AES-128</span></div>
        <div class="legend-item"><div class="legend-color" style="background:#2ecc71"></div><span><strong>23002</strong> — SecureZIP AES-192</span></div>
        <div class="legend-item"><div class="legend-color" style="background:#27ae60"></div><span><strong>23003</strong> — SecureZIP AES-256</span></div>
        <div class="legend-item"><div class="legend-color" style="background:#f39c12"></div><span><strong>JOHN</strong> — PKWARE Strong</span></div>
    </div>

    <div id="output"></div>

    <div class="info warning">
        <strong>Note:</strong> <code>$zip3$</code> PKWARE Strong is <em>not supported</em> in hashcat — use <code>john</code>.
    </div>
</div>

<script>
    const AES_EXTRA_ID = 0x9901, ZIP64_EXTRA_ID = 0x0001;
    const AES_AUTH = 10, AES_VERIFY = 2;
    let currentHashes = [];

    function processFile(){
        const file = document.getElementById('fileInput').files[0];
        const out = document.getElementById('output');
        const copyBtn = document.getElementById('copyButtonContainer');
        const fb = document.getElementById('copyFeedback');
        out.innerHTML = '<div class="no-hash">Processing...</div>';
        copyBtn.style.display='none'; fb.style.display='none'; currentHashes=[];
        if(!file){ out.innerHTML='<div class="no-hash">Select a ZIP file.</div>'; return; }
        const r = new FileReader();
        r.onload = e=>{ const view=new DataView(e.target.result); displayResults(extractZipHashes(view,e.target.result,file.name),out,copyBtn); };
        r.onerror =()=>{ out.innerHTML='<div class="no-hash">Read error.</div>'; };
        r.readAsArrayBuffer(file);
    }

    function displayResults(res,out,copyBtn){
        if(res.length===0 || res[0].error){
            out.innerHTML=`<div class="no-hash">${res[0].hash}</div>`;
            return;
        }
        currentHashes=[];
        out.innerHTML = res.map(o=>{
            currentHashes.push(o.hash);
            return `<div class="hash-line"><div class="hash-mode" style="background:${o.color}">${o.mode}</div><div class="hash-text">${o.hash}</div></div>`;
        }).join('');
        copyBtn.style.display='block';
    }

    function copyToClipboard(){
        if(!currentHashes.length){ alert('No hashes.'); return; }
        navigator.clipboard.writeText(currentHashes.join('\n')).then(()=>{ const f=document.getElementById('copyFeedback'); f.style.display='inline'; setTimeout(()=>{f.style.display='none'},2000); })
        .catch(()=>{alert('Copy failed – select manually.');});
    }

    function extractZipHashes(view,buffer,zipname){
        const len=buffer.byteLength, results=[];
        const eocd = findEOCD(view,len);
        if(!eocd) return [{hash:'Error: Invalid ZIP (EOCD not found).',mode:'ERROR',color:'#e74c3c',error:true}];

        let cdOff = Number(eocd.offset), num = Number(eocd.num);
        for(let i=0;i<num;i++){
            const cd = parseCentralHeader(view,cdOff,len);
            if(!cd){ cdOff+=46; continue; }
            if(cd.encrypted && (cd.method===0||cd.method===8||cd.method===99)){
                const loc = parseLocalHeader(view,cd.localOffset,len,cd,buffer);
                if(loc){
                    let r=null;
                    if(loc.aes.found && loc.method===99){
                        const h=getAESHashLine(view,buffer,loc);
                        if(h) r={hash:h,mode:'13600',color:'#e74c3c'};
                    }else if((loc.flags&64)||cd.verNeeded>=50){
                        const h=getStrongHashLine(view,buffer,loc,cd);
                        if(h){
                            const parts = h.split('*');
                            const bitlen = parseInt(parts[3],10);
                            let mode='JOHN', col='#f39c12';
                            if(bitlen===128){ mode='23001'; col='#1abc9c'; }
                            else if(bitlen===192){ mode='23002'; col='#2ecc71'; }
                            else if(bitlen===256){ mode='23003'; col='#27ae60'; }
                            r={hash:h,mode,color:col};
                        }
                    }
                    if(!r && cd.encrypted && (cd.method===0||cd.method===8)){
                        const h=getLegacyHashLine(view,buffer,loc,cd);
                        if(h){
                            const mode = loc.method===0?'17210':'17200';
                            const col  = loc.method===0?'#9b59b6':'#3498db';
                            r={hash:h,mode,color:col};
                        }
                    }
                    if(r) results.push(r);
                }
            }
            cdOff += cd.size;
        }
        return results.length?results:[{hash:'No encrypted files found.',mode:'—',color:'#95a5a6',error:true}];
    }

    function findEOCD(v,l){
        const min=22, maxC=65535, start=Math.max(0,l-min-maxC);
        for(let i=l-min;i>=start;i--){
            const s=v.getUint32(i,true);
            if(s===0x06054B50){
                if(v.getUint16(i+4,true)===0 && v.getUint16(i+6,true)===0)
                    return {offset:v.getUint32(i+16,true),num:v.getUint16(i+8,true)};
            }else if(s===0x06064B50){
                if(v.getUint32(i+16,true)===0 && v.getUint32(i+20,true)===0)
                    return {offset:Number(v.getBigUint64(i+48,true)),num:Number(v.getBigUint64(i+24,true))};
            }
        }
        return null;
    }

    function parseCentralHeader(v,o,l){
        if(o+46>l) return null;
        if(v.getUint32(o,true)!==0x02014B50) return null;
        const ver=v.getUint16(o+6,true)&0xFF, flags=v.getUint16(o+8,true), meth=v.getUint16(o+10,true);
        let crc=v.getUint32(o+16,true), csz=v.getUint32(o+20,true), usz=v.getUint32(o+24,true);
        const nlen=v.getUint16(o+28,true), elen=v.getUint16(o+30,true), clen=v.getUint16(o+32,true);
        let locOff=v.getUint32(o+42,true);
        let name=''; for(let i=0;i<nlen;i++) name+=String.fromCharCode(v.getUint8(o+46+i));
        let exOff=o+46+nlen, rem=elen, aes={found:false,strength:0};
        while(rem>=4){
            const id=v.getUint16(exOff,true), el=v.getUint16(exOff+2,true);
            if(id===ZIP64_EXTRA_ID && el>=8){
                let p=0, fp=exOff+4;
                if(usz===0xFFFFFFFF) usz=Number(v.getBigUint64(fp+p,true)), p+=8;
                if(csz===0xFFFFFFFF) csz=Number(v.getBigUint64(fp+p,true)), p+=8;
                if(locOff===0xFFFFFFFF) locOff=Number(v.getBigUint64(fp+p,true));
            }else if(id===AES_EXTRA_ID && el===7){
                const vid=v.getUint16(exOff+6,true), str=v.getUint8(exOff+8);
                if(vid===0x4541 && str>=1 && str<=3) aes={found:true,strength:str};
            }
            exOff+=4+el; rem-=4+el;
        }
        return {name,verNeeded:ver,encrypted:!!(flags&1),flags,method:meth,crc,compSize:csz,uncompSize:usz,localOffset:locOff,aes,size:46+nlen+elen+clen};
    }

    function parseLocalHeader(v,o,l,cd,b){
        if(o+30>l) return null;
        if(v.getUint32(o,true)!==0x04034B50) return null;
        const flags=v.getUint16(o+6,true), meth=v.getUint16(o+8,true), mod=v.getUint16(o+10,true);
        let crc=0,csz=0,usz=0; const unk=(flags&8)!==0;
        let pos=o+14;
        if(!unk){ crc=v.getUint32(pos,true); csz=v.getUint32(pos+4,true); usz=v.getUint32(pos+8,true); pos+=12; }else pos+=12;
        const nlen=v.getUint16(pos,true), elen=v.getUint16(pos+2,true);
        const dataOff=o+30+nlen+elen;
        if(unk){
            let found=false;
            for(let p=dataOff;p<l-28;p++){
                const sig=v.getUint32(p,true);
                if(sig===0x08074B50){
                    const comp=v.getUint32(p+8,true);
                    if(comp===p-dataOff){ crc=v.getUint32(p+4,true); csz=comp; usz=v.getUint32(p+12,true); found=true; break; }
                }
            }
            if(!found) return null;
        }
        if(csz===0) csz=cd.compSize; if(usz===0) usz=cd.uncompSize; if(crc===0) crc=cd.crc;
        return {dataOffset:dataOff,flags,method:meth,lastmodTime:mod,crc,compSize:csz,uncompSize:usz,aes:cd.aes};
    }

    function bytesToHex(a){return Array.from(a).map(b=>b.toString(16).padStart(2,'0')).join('');}

    function getAESHashLine(v,b,loc){
        const {dataOffset,compSize,aes}=loc, str=aes.strength, sl=4+4*str;
        if(compSize<sl+2+10) return null;
        const salt=new Uint8Array(b,dataOffset,sl);
        const ver=new Uint8Array(b,dataOffset+sl,2);
        const real=compSize-sl-2-10;
        const enc=new Uint8Array(b,dataOffset+sl+2,real);
        const auth=new Uint8Array(b,dataOffset+sl+2+real,10);
        return `$zip2$*0*${str}*0*${bytesToHex(salt)}*${bytesToHex(ver)}*${real.toString(16)}*${bytesToHex(enc)}*${bytesToHex(auth)}*$/zip2$`;
    }

    function getStrongHashLine(v,b,loc,cd){
        const {dataOffset}=loc;
        let ivSz=v.getUint16(dataOffset,true), iv;
        if(ivSz===0){
            const ivb=new Uint8Array(12); const dv=new DataView(ivb.buffer);
            dv.setUint32(0,cd.crc,true); dv.setBigUint64(4,BigInt(loc.uncompSize),true);
            iv=ivb; ivSz=12;
        }else if(ivSz>16) return null;
        else iv=new Uint8Array(b,dataOffset+2,ivSz);
        const pos=dataOffset+2+ivSz+4;
        if(v.getUint16(pos,true)!==3) return null;
        let alg=v.getUint16(pos+2,true);
        if(![0x660E,0x660F,0x6610].includes(alg)) return null;
        alg=1;
        const bitlen=v.getUint16(pos+4,true);
        const erdSz=v.getUint16(pos+10,true);
        if(erdSz>256) return null;
        const erd=new Uint8Array(b,pos+12,erdSz);
        return `$zip3$*0*${alg}*${bitlen}*0*${bytesToHex(iv)}*${bytesToHex(erd)}*0*0*0`;
    }

    function getLegacyHashLine(v,b,loc,cd){
        const {dataOffset,flags,lastmodTime,method}=loc;
        const {verNeeded,crc:cdCrc,compSize:cdCsz,uncompSize:cdUsz}=cd;
        const unk=(flags&8)!==0, safeCrc=cdCrc||0;
        const chk = verNeeded>=20?1:2;
        let cs;
        if(unk){
            cs=((lastmodTime>>8)&0xFF).toString(16).padStart(2,'0')+
               (lastmodTime&0xFF).toString(16).padStart(2,'0');
        }else{
            cs=((safeCrc>>24)&0xFF).toString(16).padStart(2,'0')+
               ((safeCrc>>16)&0xFF).toString(16).padStart(2,'0');
        }
        const cl=cdCsz||loc.compSize||0, ul=cdUsz||loc.uncompSize||0;
        const crHex=safeCrc.toString(16).padStart(8,'0');
        const dataHex=bytesToHex(new Uint8Array(b,dataOffset,cl));
        const type=1,u2=2,u3=0,u4=0;
        const cHex=cl.toString(16), uHex=ul.toString(16), offHex=dataOffset.toString(16);
        const crcHi=((safeCrc>>16)&0xFFFF).toString(16).padStart(4,'0');
        return `$pkzip2$${type}*${chk}*${u2}*${u3}*${cHex}*${uHex}*${crHex}*${u4}*${offHex}*${method}*${cHex}*${crcHi}*${cs}*${dataHex}$/pkzip2$`;
    }
</script>
</body>
</html>
