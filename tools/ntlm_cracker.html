<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebGL NTLM Hash Cracker</title>
  <style>
    :root {
      --bg-primary: #0a0a0a;
      --bg-secondary: #1a1a1a;
      --text-primary: #ffffff;
      --text-secondary: #b0b0b0;
      --accent: #00ff88;
      --border: #333333;
      --input-bg: #2a2a2a;
      --input-border: #444444;
      --button-bg: #00ff88;
      --button-hover: #00cc6a;
      --button-stop: #ff4d4d;
      --button-stop-hover: #cc3b3b;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
      padding: 2rem;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .container {
      max-width: 500px;
      width: 100%;
      background: var(--bg-secondary);
      padding: 2rem;
      border-radius: 12px;
      box-shadow: var(--shadow);
      border: 1px solid var(--border);
    }

    h1 {
      text-align: center;
      margin-bottom: 2rem;
      color: var(--accent);
      font-size: 1.5rem;
      font-weight: 600;
    }

    .form-group {
      margin-bottom: 1.5rem;
    }

    label {
      display: block;
      margin-bottom: 0.5rem;
      color: var(--text-secondary);
      font-size: 0.875rem;
      font-weight: 500;
    }

    input[type="file"],
    input[type="number"],
    textarea {
      width: 100%;
      padding: 0.75rem;
      background: var(--input-bg);
      border: 1px solid var(--input-border);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 1rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      resize: vertical;
      min-height: 80px;
    }

    textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(0, 255, 136, 0.1);
    }

    input[type="checkbox"] {
      margin-right: 0.5rem;
      width: auto;
    }

    input[type="file"]:focus,
    input[type="number"]:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(0, 255, 136, 0.1);
    }

    input[type="file"] {
      padding: 0.5rem;
    }

    .options-toggle {
      width: 100%;
      padding: 0.75rem;
      background: var(--input-bg);
      border: 1px solid var(--input-border);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 1rem;
      cursor: pointer;
      transition: background-color 0.2s ease;
      margin-bottom: 1rem;
      text-align: left;
    }

    .options-toggle:hover {
      background: var(--border);
    }

    .options-toggle.expanded {
      background: var(--accent);
      color: #000;
    }

    .options-content {
      display: none;
      margin-top: 1rem;
      padding: 1rem;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--bg-primary);
    }

    .options-content.expanded {
      display: block;
    }

    .rule-group {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1rem;
    }

    .rule-group h3 {
      margin-bottom: 0.5rem;
      color: var(--accent);
      font-size: 1rem;
    }

    .rule-group p {
      color: var(--text-secondary);
      font-size: 0.75rem;
      margin-bottom: 0.5rem;
    }

    .button-group {
      display: flex;
      gap: 1rem;
    }

    button {
      flex: 1;
      padding: 1rem;
      background: var(--button-bg);
      color: #000000;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.2s ease, transform 0.1s ease;
      margin-top: 1rem;
    }

    button:hover:not(:disabled) {
      background: var(--button-hover);
      transform: translateY(-1px);
    }

    button:disabled {
      background: var(--text-secondary);
      cursor: not-allowed;
      transform: none;
    }

    button:active {
      transform: translateY(0);
    }

    #stopButton {
      background: var(--button-stop);
    }

    #stopButton:hover:not(:disabled) {
      background: var(--button-stop-hover);
    }

    #result {
      margin-top: 1.5rem;
      padding: 1rem;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      text-align: left;
      font-weight: 500;
      min-height: 1.25rem;
      white-space: pre-line;
    }

    #result.processing {
      color: var(--accent);
    }

    .progress-container {
      margin-top: 1rem;
      display: none;
    }

    .progress-container.active {
      display: block;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: var(--input-bg);
      border-radius: 4px;
      overflow: hidden;
      border: 1px solid var(--border);
    }

    .progress-fill {
      height: 100%;
      background: var(--accent);
      width: 0%;
      transition: width 0.3s ease;
    }

    .progress-text {
      text-align: center;
      margin-top: 0.5rem;
      font-size: 0.875rem;
      color: var(--text-secondary);
    }

    .timing {
      font-size: 0.875rem;
      color: var(--text-secondary);
      margin-top: 0.5rem;
      text-align: left;
    }

    canvas {
      display: none;
    }

    @media (max-width: 600px) {
      body {
        padding: 1rem;
      }
      .container {
        padding: 1.5rem;
      }
      .button-group {
        flex-direction: column;
        gap: 0.5rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>NTLM Hash Cracker</h1>
    <div class="form-group">
      <label for="hashInput">NTLM Hashes (one per line, optional if using hash file)</label>
      <textarea id="hashInput" placeholder="One hash per line&#10;e.g.&#10;8846f7eaee8fb117ad06bdd830b7586c&#10;aad3b435b51404eeaad3b435b51404ee"></textarea>
    </div>
    <div class="form-group">
      <label for="hashFileInput">Hash File (.txt, one hash per line, optional)</label>
      <input type="file" id="hashFileInput" accept=".txt">
    </div>
    <div class="form-group">
      <label for="dictionaryInput">Dictionary File (.txt)</label>
      <input type="file" id="dictionaryInput" accept=".txt">
    </div>
    <button class="options-toggle" onclick="toggleOptions()">Expand Rules Options</button>
    <div class="options-content" id="optionsContent">
      <div class="rule-group">
        <h3>Case Transformations</h3>
        <p>Apply case changes to base words from the dictionary.</p>
        <label><input type="checkbox" id="capitalizeFirst"> Capitalize first character (e.g., sherlock → Sherlock)</label>
        <label><input type="checkbox" id="uppercaseAll"> Uppercase entire word (e.g., sherlock → SHERLOCK)</label>
      </div>
      <div class="rule-group">
        <h3>Custom Prefixes</h3>
        <p>One prefix per line. These will be added before base words (after case transformations).</p>
        <textarea id="customPrefixes" placeholder="One prefix per line&#10;e.g.&#10;abc&#10;pass"></textarea>
        <label style="margin-top: 0.5rem; display: block;"><input type="checkbox" id="includeYearPrefix"> Also prepend years from the range below</label>
      </div>
      <div class="rule-group">
        <h3>Custom Suffixes</h3>
        <p>One suffix per line. These will be added after base words (after prefixes).</p>
        <textarea id="customSuffixes" placeholder="One suffix per line&#10;e.g.&#10;!&#10;123"></textarea>
        <label style="margin-top: 0.5rem; display: block;"><input type="checkbox" id="includeYearSuffix"> Also append years from the range below</label>
      </div>
      <div class="rule-group">
        <h3>Year Range (for prefixes/suffixes)</h3>
        <p>Only used if year checkboxes above are enabled. Generates variants like "2025sherlock" or "sherlock2025".</p>
        <label>Start Year: <input type="number" id="minYear" value="2000" min="1900" max="2100" style="width: 80px; display: inline;"> End Year: <input type="number" id="maxYear" value="2025" min="1900" max="2100" style="width: 80px; display: inline;"></label>
      </div>
    </div>
    <canvas id="webglCanvas"></canvas>
    <div class="button-group">
      <button id="crackButton" onclick="startCracking()">Start Cracking</button>
      <button id="stopButton" onclick="stopCracking()" disabled>Stop Cracking</button>
      <button id="clearButton" onclick="clearInputs()">Clear Inputs</button>
    </div>
    <div class="progress-container" id="progressContainer">
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div class="progress-text" id="progressText"></div>
    </div>
    <p id="result">Result: Waiting...</p>
    <div class="timing" id="timingInfo" style="display: none;"></div>
  </div>

  <script>
    let isStopping = false;
    let gl = null;
    let program = null;
    let canvas = null;
    let dictionaryData = [];
    let targetHashes = [];
    let targetHashStrings = [];
    let webGLInitialized = false;

    function toggleOptions() {
      const toggleBtn = event.target;
      const content = document.getElementById('optionsContent');
      const isExpanded = content.classList.contains('expanded');
      if (isExpanded) {
        content.classList.remove('expanded');
        toggleBtn.textContent = 'Expand Rules Options';
        toggleBtn.classList.remove('expanded');
      } else {
        content.classList.add('expanded');
        toggleBtn.textContent = 'Collapse Rules Options';
        toggleBtn.classList.add('expanded');
      }
    }

    function stopCracking() {
      isStopping = true;
      const crackButton = document.getElementById('crackButton');
      const stopButton = document.getElementById('stopButton');
      const resultEl = document.getElementById('result');
      const progressContainer = document.getElementById('progressContainer');
      crackButton.disabled = false;
      crackButton.textContent = 'Start Cracking';
      stopButton.disabled = true;
      resultEl.textContent = 'Cracking stopped by user.';
      resultEl.style.color = '#ff6b6b';
      resultEl.classList.remove('processing');
      progressContainer.classList.remove('active');
    }

    function clearInputs() {
      document.getElementById('hashInput').value = '';
      document.getElementById('hashFileInput').value = '';
      document.getElementById('dictionaryInput').value = '';
      document.getElementById('customPrefixes').value = '';
      document.getElementById('customSuffixes').value = '';
      document.getElementById('capitalizeFirst').checked = false;
      document.getElementById('uppercaseAll').checked = false;
      document.getElementById('includeYearPrefix').checked = false;
      document.getElementById('includeYearSuffix').checked = false;
      document.getElementById('minYear').value = '2000';
      document.getElementById('maxYear').value = '2025';
      document.getElementById('result').textContent = 'Result: Waiting...';
      document.getElementById('result').style.color = '';
      document.getElementById('progressContainer').classList.remove('active');
      document.getElementById('progressFill').style.width = '0%';
      document.getElementById('progressText').textContent = '';
      document.getElementById('timingInfo').style.display = 'none';
      document.getElementById('timingInfo').innerHTML = '';
      dictionaryData = [];
      targetHashes = [];
      targetHashStrings = [];
    }

    function initializeWebGL() {
      canvas = document.getElementById('webglCanvas');
      if (!canvas) {
        console.error('Canvas element with ID "webglCanvas" not found in the DOM.');
        return false;
      }
      gl = canvas.getContext('webgl2');
      if (!gl) {
        console.error('WebGL2 not supported!');
        return false;
      }

      // Vertex shader
      const vertexShaderSource = `#version 300 es
        in vec2 a_position;
        void main() {
          gl_Position = vec4(a_position, 0.0, 1.0);
        }
      `;

      // Fragment shader with corrected hash index encoding
      const fragmentShaderSource = `#version 300 es
        precision highp float;
        precision highp int;
        out vec4 fragColor;
        uniform sampler2D u_dictionary;
        uniform sampler2D u_targetHashes;
        uniform ivec2 u_texSize;
        uniform int u_numPass;
        uniform int u_numHashes;

        uint F(uint x, uint y, uint z) {
          return (x & y) | ((~x) & z);
        }

        uint G(uint x, uint y, uint z) {
          return (x & y) | (x & z) | (y & z);
        }

        uint H(uint x, uint y, uint z) {
          return x ^ y ^ z;
        }

        uint lrot(uint value, uint n) {
          return (value << n) | (value >> (32u - n));
        }

        bool compareHash(uvec4 computed, int hashIdx) {
          float tex_w = float(u_numHashes * 4);
          uvec4 target;
          for (int i = 0; i < 4; i++) {
            float tex_x = (float(hashIdx * 4 + i) + 0.5) / tex_w;
            vec4 samp = texture(u_targetHashes, vec2(tex_x, 0.5));
            target[i] = uint(round(samp.r * 255.0)) | (uint(round(samp.g * 255.0)) << 8u) | (uint(round(samp.b * 255.0)) << 16u) | (uint(round(samp.a * 255.0)) << 24u);
          }
          return computed == target;
        }

        void main() {
          int pass_id = int(gl_FragCoord.x);
          if (pass_id >= u_numPass) {
            fragColor = vec4(0.0);
            return;
          }
          float tex_w = float(u_texSize.x);
          float base_start = float(pass_id * 16);
          uint message[64];
          for (int px = 0; px < 16; px++) {
            float tex_x = (base_start + float(px) + 0.5) / tex_w;
            vec2 texc = vec2(tex_x, 0.5);
            vec4 samp = texture(u_dictionary, texc);
            int off = px * 4;
            message[off + 0] = uint(round(samp.r * 255.0));
            message[off + 1] = uint(round(samp.g * 255.0));
            message[off + 2] = uint(round(samp.b * 255.0));
            message[off + 3] = uint(round(samp.a * 255.0));
          }
          // Compute MD4 (1 block)
          uvec4 hash_val = uvec4(0x67452301u, 0xefcdab89u, 0x98badcfeu, 0x10325476u);
          for (int blk = 0; blk < 1; blk++) {
            int base = blk * 64;
            uint X[16];
            for (int i = 0; i < 16; i++) {
              int off = base + i * 4;
              X[i] = message[off + 0] | (message[off + 1] << 8u) | (message[off + 2] << 16u) | (message[off + 3] << 24u);
            }
            uvec4 working = hash_val;
            // Round 1
            int S1[4] = int[](3, 7, 11, 19);
            for (int n = 0; n < 16; n++) {
              int r = n % 4;
              int i = (4 - r) % 4;
              int j = (i + 1) % 4;
              int k = (i + 2) % 4;
              int l = (i + 3) % 4;
              uint f = F(working[j], working[k], working[l]);
              uint hn = working[i] + f + X[n];
              working[i] = lrot(hn, uint(S1[r]));
            }
            // Round 2
            int S2[4] = int[](3, 5, 9, 13);
            for (int n = 0; n < 16; n++) {
              int r = n % 4;
              int i = (4 - r) % 4;
              int j = (i + 1) % 4;
              int k = (i + 2) % 4;
              int l = (i + 3) % 4;
              int Kn = (n % 4) * 4 + (n / 4);
              uint f = G(working[j], working[k], working[l]);
              uint hn = working[i] + f + X[Kn] + 0x5a827999u;
              working[i] = lrot(hn, uint(S2[r]));
            }
            // Round 3
            int S3[4] = int[](3, 9, 11, 15);
            int Ki[16] = int[](0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15);
            for (int n = 0; n < 16; n++) {
              int r = n % 4;
              int i = (4 - r) % 4;
              int j = (i + 1) % 4;
              int k = (i + 2) % 4;
              int l = (i + 3) % 4;
              int Kn = Ki[n];
              uint f = H(working[j], working[k], working[l]);
              uint hn = working[i] + f + X[Kn] + 0x6ed9eba1u;
              working[i] = lrot(hn, uint(S3[r]));
            }
            hash_val += working;
          }
          bool found = false;
          int foundHashIdx = -1;
          for (int h = 0; h < u_numHashes; h++) {
            if (compareHash(hash_val, h)) {
              found = true;
              foundHashIdx = h;
              break;
            }
          }
          if (found) {
            // Encode hash index as an integer in the red channel (0.0 to 1.0)
            float index = float(foundHashIdx + 1);
            fragColor = vec4(index / 255.0, 0.0, 0.0, 1.0);
          } else {
            fragColor = vec4(0.0, 0.0, 0.0, 0.0);
          }
        }
      `;

      // Compile shader
      function compileShader(source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('Shader compile error:', gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      // Create program
      const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
      const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
      program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program link error:', gl.getProgramInfoLog(program));
        return false;
      }
      gl.useProgram(program);

      // Set up vertex buffer for full-screen quad
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      const positions = new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1,
      ]);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
      const positionLocation = gl.getAttribLocation(program, 'a_position');
      gl.enableVertexAttribArray(positionLocation);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
      return true;
    }

    // Initialize WebGL after DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      webGLInitialized = initializeWebGL();
      console.log('WebGL initialized:', webGLInitialized);
    });

    // Handle dictionary file upload
    document.getElementById('dictionaryInput').addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        dictionaryData = e.target.result.split('\n').map(line => line.trim()).filter(line => line.length > 0);
        console.log('Dictionary loaded:', dictionaryData);
      };
      reader.readAsText(file);
    });

    // Handle hash file upload
    document.getElementById('hashFileInput').addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        const hashes = e.target.result.split('\n').map(line => line.trim()).filter(line => line.length > 0);
        targetHashes = [];
        targetHashStrings = [];
        for (let hash of hashes) {
          const parsed = parseNTLMHash(hash);
          if (parsed) {
            targetHashes.push(parsed);
            targetHashStrings.push(hash.toLowerCase());
          }
        }
        console.log('Hashes loaded from file:', targetHashStrings);
      };
      reader.readAsText(file);
    });

    // Convert string to UTF-16LE Uint8Array
    function stringToUTF16LE(str) {
      const buf = new ArrayBuffer(str.length * 2);
      const view = new Uint16Array(buf);
      for (let i = 0; i < str.length; i++) {
        view[i] = str.charCodeAt(i);
      }
      return new Uint8Array(buf);
    }

    // Pad message for MD4
    function padForMD4(inputBytes) {
      let index = inputBytes.length;
      let msg = new Uint8Array(inputBytes.length + 1 + 8 + 64);
      msg.set(inputBytes);
      msg[index++] = 0x80;
      while ((index % 64) !== 56) {
        msg[index++] = 0;
      }
      const dv = new DataView(msg.buffer);
      dv.setBigUint64(index, BigInt(inputBytes.length * 8), true);
      const fullLen = index + 8;
      return msg.slice(0, fullLen);
    }

    // Parse NTLM hash to uvec4
    function parseNTLMHash(hexStr) {
      hexStr = hexStr.toLowerCase();
      if (!/^[0-9a-f]{32}$/.test(hexStr)) {
        console.warn(`Invalid NTLM hash: ${hexStr}. Must be 32 hexadecimal characters.`);
        return null;
      }
      const bytes = new Uint8Array(16);
      for (let i = 0; i < 32; i += 2) {
        bytes[i / 2] = parseInt(hexStr.substr(i, 2), 16);
      }
      const u32 = new Uint32Array(4);
      const dv = new DataView(bytes.buffer);
      for (let i = 0; i < 4; i++) {
        u32[i] = dv.getUint32(i * 4, true);
      }
      return u32;
    }

    // Format duration
    function formatDuration(durationMs) {
      let ms = durationMs;
      const days = Math.floor(ms / (1000 * 60 * 60 * 24));
      ms -= days * (1000 * 60 * 60 * 24);
      const hours = Math.floor(ms / (1000 * 60 * 60));
      ms -= hours * (1000 * 60 * 60);
      const minutes = Math.floor(ms / (1000 * 60));
      ms -= minutes * (1000 * 60);
      const seconds = Math.floor(ms / 1000);
      ms -= seconds * 1000;
      const nanoseconds = Math.round((ms % 1) * 1e6);
      ms = Math.floor(ms);
      return `${days}d ${hours.toString().padStart(2, '0')}h ${minutes.toString().padStart(2, '0')}m ${seconds.toString().padStart(2, '0')}s ${ms.toString().padStart(3, '0')}ms ${nanoseconds.toString().padStart(9, '0')}ns`;
    }

    // Estimate total variants for progress and hashes per second
    function estimateTotalVariants(numPass) {
      let multiplier = 1; // Base word
      if (document.getElementById('capitalizeFirst').checked) multiplier += 1;
      if (document.getElementById('uppercaseAll').checked) multiplier += 1;
      const customPrefixes = document.getElementById('customPrefixes').value.split('\n').map(s => s.trim()).filter(s => s.length > 0);
      if (customPrefixes.length > 0) multiplier *= (1 + customPrefixes.length);
      const customSuffixes = document.getElementById('customSuffixes').value.split('\n').map(s => s.trim()).filter(s => s.length > 0);
      if (customSuffixes.length > 0) multiplier *= (1 + customSuffixes.length);
      const includeYearPrefix = document.getElementById('includeYearPrefix').checked;
      const includeYearSuffix = document.getElementById('includeYearSuffix').checked;
      const minYear = parseInt(document.getElementById('minYear').value);
      const maxYear = parseInt(document.getElementById('maxYear').value);
      const numYears = maxYear - minYear + 1;
      if (includeYearPrefix) multiplier *= (1 + numYears);
      if (includeYearSuffix) multiplier *= (1 + numYears);
      return numPass * multiplier;
    }

    // Async batch processor
    async function processBatch(b, numBatches, originalBatchSize, targetHashes, targetHashStrings, numPass, totalVariantsCounter, totalVariants, resultEl, allMatches, totalHashes) {
      if (isStopping) {
        console.log('Batch processing stopped');
        return { foundMatches: [], batch: b };
      }
      console.log(`Processing batch ${b + 1}/${numBatches}`);
      const start = b * originalBatchSize;
      const end = Math.min(start + originalBatchSize, numPass);
      const originals = dictionaryData.slice(start, end);
      const numOriginals = originals.length;
      if (numOriginals === 0) {
        console.warn('No passwords in batch', b);
        return { foundMatches: [], batch: b };
      }
      let testPasswords = [];
      for (let orig of originals) {
        const variants = generateVariants(orig);
        testPasswords.push(...variants);
        totalVariantsCounter.count += variants.length;
        // Debug: Log variants for the first few words in the first batch
        if (b === 0 && testPasswords.length <= 10) {
          console.log(`Variants for "${orig}":`, variants);
        }
      }
      const numTests = testPasswords.length;
      if (numTests === 0) {
        console.warn('No test passwords generated for batch', b);
        return { foundMatches: [], batch: b };
      }

      const maxPassesPerRender = 512; // Safe limit to avoid exceeding texture size
      const numSubBatches = Math.ceil(numTests / maxPassesPerRender);
      const pixelsPerPass = 16;

      let foundMatches = [];

      // Create hash texture
      const hashTexWidth = targetHashes.length * 4; // 4 pixels per hash (1 per uint)
      const hashTexHeight = 1;
      const hashTexData = new Uint8Array(hashTexWidth * hashTexHeight * 4);
      for (let h = 0; h < targetHashes.length; h++) {
        const hash = targetHashes[h];
        for (let i = 0; i < 4; i++) {
          const baseIdx = (h * 4 + i) * 4;
          const bytes = new Uint8Array(new Uint32Array([hash[i]]).buffer);
          hashTexData[baseIdx + 0] = bytes[0];
          hashTexData[baseIdx + 1] = bytes[1];
          hashTexData[baseIdx + 2] = bytes[2];
          hashTexData[baseIdx + 3] = bytes[3];
        }
      }
      console.log('Hash texture data:', Array.from(hashTexData).map(b => b.toString(16).padStart(2, '0')).join('')); // Debug hash texture
      const hashTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, hashTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, hashTexWidth, hashTexHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, hashTexData);
      if (gl.getError() !== gl.NO_ERROR) {
        console.error('WebGL error creating hash texture');
        return { foundMatches: [], batch: b };
      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      for (let sub = 0; sub < numSubBatches; sub++) {
        if (isStopping) {
          console.log('Sub-batch processing stopped');
          break;
        }
        const subStart = sub * maxPassesPerRender;
        const subEnd = Math.min(subStart + maxPassesPerRender, numTests);
        const subNum = subEnd - subStart;
        const subTests = testPasswords.slice(subStart, subEnd);
        console.log(`Processing sub-batch ${sub + 1}/${numSubBatches}, ${subNum} passwords`);

        // Update status to "In Progress..." on first sub-batch of first batch
        if (b === 0 && sub === 0) {
          resultEl.textContent = 'In Progress...';
        }

        // Update progress based on total variants
        const variantsProcessed = totalVariantsCounter.count - (numTests - subNum);
        const overallProgress = totalVariants > 0 ? (variantsProcessed / totalVariants) * 100 : 0;
        const matchedHashes = new Set(allMatches.map(m => m.hash));
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        progressFill.style.width = `${Math.min(overallProgress, 100)}%`;
        progressText.textContent = `Processing batch ${b + 1}/${numBatches} (sub ${sub + 1}/${numSubBatches}, ${numOriginals} originals, ${numTests} tests, ${matchedHashes.size}/${totalHashes} hashes cracked) - ${Math.round(overallProgress)}% complete`;

        const texWidth = subNum * pixelsPerPass;
        const texHeight = 1;
        const texData = new Uint8Array(texWidth * texHeight * 4);
        for (let p = 0; p < subNum; p++) {
          const inputBytes = stringToUTF16LE(subTests[p]);
          if (inputBytes.length > 55) {
            console.warn(`Password "${subTests[p]}" is long (${inputBytes.length} bytes); hash may be incorrect (1-block limit).`);
          }
          const paddedBytes = padForMD4(inputBytes);
          const passBytes = new Uint8Array(64).fill(0);
          passBytes.set(paddedBytes.slice(0, 64));
          const baseIdx = p * pixelsPerPass * 4;
          for (let px = 0; px < pixelsPerPass; px++) {
            const dataIdx = baseIdx + px * 4;
            const msgOff = px * 4;
            texData[dataIdx + 0] = passBytes[msgOff + 0];
            texData[dataIdx + 1] = passBytes[msgOff + 1];
            texData[dataIdx + 2] = passBytes[msgOff + 2];
            texData[dataIdx + 3] = passBytes[msgOff + 3];
          }
        }

        // Create password texture
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, texWidth, texHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, texData);
        if (gl.getError() !== gl.NO_ERROR) {
          console.error('WebGL error creating password texture');
          return { foundMatches: [], batch: b };
        }
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        // Bind textures to texture units
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, hashTexture);

        // Set uniforms
        const texSizeLoc = gl.getUniformLocation(program, 'u_texSize');
        gl.uniform2i(texSizeLoc, texWidth, texHeight);
        const numPassLoc = gl.getUniformLocation(program, 'u_numPass');
        gl.uniform1i(numPassLoc, subNum);
        const numHashesLoc = gl.getUniformLocation(program, 'u_numHashes');
        gl.uniform1i(numHashesLoc, targetHashes.length);
        gl.uniform1i(gl.getUniformLocation(program, 'u_dictionary'), 0);
        gl.uniform1i(gl.getUniformLocation(program, 'u_targetHashes'), 1);

        // Render
        canvas.width = subNum;
        canvas.height = 1;
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        if (gl.getError() !== gl.NO_ERROR) {
          console.error('WebGL error during rendering');
          return { foundMatches: [], batch: b };
        }

        // Read result
        const pixels = new Uint8Array(subNum * 4);
        gl.readPixels(0, 0, subNum, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        if (gl.getError() !== gl.NO_ERROR) {
          console.error('WebGL error reading pixels');
          return { foundMatches: [], batch: b };
        }
        // Debug: Log raw pixel values
        console.log('Raw pixel values:', Array.from(pixels).map((v, i) => `${i}: ${v}`).join(', '));
        for (let p = 0; p < subNum; p++) {
          const off = p * 4;
          if (pixels[off] > 0) {
            const rawRed = pixels[off];
            const hashIdx = Math.round((rawRed / 255.0) * 255.0) - 1;
            console.log(`Pixel ${p}, rawRed: ${rawRed}, calculated hashIdx: ${hashIdx}, password: ${subTests[p]}`);
            if (hashIdx >= 0 && hashIdx < targetHashStrings.length) {
              foundMatches.push({ hash: targetHashStrings[hashIdx], password: subTests[p] });
              console.log(`Match found: Hash ${targetHashStrings[hashIdx]} -> Password ${subTests[p]}`);
            } else {
              console.warn(`Invalid hash index ${hashIdx} for password ${subTests[p]}`);
            }
          }
        }

        // Yield to UI thread
        await new Promise(resolve => setTimeout(resolve, 0));
      }

      return { foundMatches, batch: b };
    }

    // Generate variants for a password based on enabled rules
    function generateVariants(pw) {
      const variants = new Set([pw]);
      const capitalizeFirst = document.getElementById('capitalizeFirst').checked;
      const uppercaseAll = document.getElementById('uppercaseAll').checked;
      const customPrefixes = document.getElementById('customPrefixes').value.split('\n').map(s => s.trim()).filter(s => s.length > 0);
      const customSuffixes = document.getElementById('customSuffixes').value.split('\n').map(s => s.trim()).filter(s => s.length > 0);
      const includeYearPrefix = document.getElementById('includeYearPrefix').checked;
      const includeYearSuffix = document.getElementById('includeYearSuffix').checked;
      const minYear = parseInt(document.getElementById('minYear').value);
      const maxYear = parseInt(document.getElementById('maxYear').value);

      // Case variants
      if (capitalizeFirst && pw.length > 0) {
        variants.add(pw[0].toUpperCase() + pw.slice(1));
      }
      if (uppercaseAll) {
        variants.add(pw.toUpperCase());
      }

      // Apply custom prefixes
      if (customPrefixes.length > 0) {
        console.log('Applying prefixes:', customPrefixes);
        const current = Array.from(variants);
        variants.clear();
        for (let v of current) {
          variants.add(v);
          for (let pref of customPrefixes) {
            variants.add(pref + v);
          }
        }
      }

      // Apply custom suffixes
      if (customSuffixes.length > 0) {
        console.log('Applying suffixes:', customSuffixes);
        const current = Array.from(variants);
        variants.clear();
        for (let v of current) {
          variants.add(v);
          for (let suff of customSuffixes) {
            variants.add(v + suff);
          }
        }
      }

      // Year range variants
      if (includeYearPrefix || includeYearSuffix) {
        const current = Array.from(variants);
        variants.clear();
        for (let v of current) {
          variants.add(v);
          for (let year = minYear; year <= maxYear; year++) {
            const yearStr = year.toString();
            if (includeYearPrefix) {
              variants.add(yearStr + v);
            }
            if (includeYearSuffix) {
              variants.add(v + yearStr);
            }
          }
        }
      }

      return Array.from(variants);
    }

    // Expose startCracking to global
    window.startCracking = async function() {
      if (!webGLInitialized || !gl || !program || !canvas) {
        alert('WebGL2 initialization failed or canvas not found. Please ensure your browser supports WebGL2 and the canvas element exists.');
        return;
      }

      const crackButton = document.getElementById('crackButton');
      const stopButton = document.getElementById('stopButton');
      const hashInput = document.getElementById('hashInput').value;
      const resultEl = document.getElementById('result');
      const progressContainer = document.getElementById('progressContainer');
      const progressFill = document.getElementById('progressFill');
      const progressText = document.getElementById('progressText');
      const timingInfo = document.getElementById('timingInfo');

      // Clear previous output and reset state
      isStopping = false;
      resultEl.textContent = 'Result: Waiting...';
      resultEl.style.color = '';
      resultEl.classList.remove('processing');
      progressContainer.classList.remove('active');
      progressFill.style.width = '0%';
      progressText.textContent = '';
      timingInfo.style.display = 'none';
      timingInfo.innerHTML = '';

      // Collect target hashes from textarea and file
      let targetHashesLocal = [];
      let targetHashStringsLocal = [];
      if (hashInput) {
        const hashes = hashInput.split('\n').map(line => line.trim()).filter(line => line.length > 0);
        for (let hash of hashes) {
          const parsed = parseNTLMHash(hash);
          if (parsed) {
            targetHashesLocal.push(parsed);
            targetHashStringsLocal.push(hash.toLowerCase());
          } else {
            console.warn(`Invalid hash in textarea: ${hash}`);
          }
        }
      }
      // Combine with file hashes
      for (let i = 0; i < targetHashes.length; i++) {
        targetHashesLocal.push(targetHashes[i]);
        targetHashStringsLocal.push(targetHashStrings[i]);
      }
      if (targetHashesLocal.length === 0) {
        alert('Please provide at least one valid NTLM hash via textarea or file.');
        return;
      }
      if (dictionaryData.length === 0) {
        alert('Please upload a dictionary file.');
        return;
      }

      // Log custom prefixes, suffixes, and hashes for debugging
      const customPrefixes = document.getElementById('customPrefixes').value.split('\n').map(s => s.trim()).filter(s => s.length > 0);
      const customSuffixes = document.getElementById('customSuffixes').value.split('\n').map(s => s.trim()).filter(s => s.length > 0);
      console.log('Custom prefixes:', customPrefixes);
      console.log('Custom suffixes:', customSuffixes);
      console.log('Target hashes:', targetHashStringsLocal);

      // Dynamic batch size based on rules
      const numEnabledRules = [
        document.getElementById('capitalizeFirst').checked,
        document.getElementById('uppercaseAll').checked,
        customPrefixes.length > 0,
        customSuffixes.length > 0,
        document.getElementById('includeYearPrefix').checked,
        document.getElementById('includeYearSuffix').checked
      ].filter(Boolean).length;
      const originalBatchSize = Math.max(10, 1024 - (numEnabledRules * 200));

      const numPass = dictionaryData.length;
      const numBatches = Math.ceil(numPass / originalBatchSize);
      const totalVariants = estimateTotalVariants(numPass);
      const totalHashes = targetHashesLocal.length;
      console.log(`Starting cracking: ${numPass} passwords, ${numBatches} batches, ${totalVariants} total variants, ${totalHashes} hashes`);

      // Disable button and start
      crackButton.disabled = true;
      crackButton.textContent = 'Cracking...';
      stopButton.disabled = false;

      // Record start time
      const startDate = new Date();
      const startPerf = performance.now();

      // Show progress bar
      progressContainer.classList.add('active');
      resultEl.classList.add('processing');
      resultEl.textContent = 'Starting...';

      let allMatches = [];
      let completedBatches = 0;
      const totalVariantsCounter = { count: 0 };

      for (let b = 0; b < numBatches; b++) {
        if (isStopping) break;
        const result = await processBatch(b, numBatches, originalBatchSize, targetHashesLocal, targetHashStringsLocal, numPass, totalVariantsCounter, totalVariants, resultEl, allMatches, totalHashes);
        completedBatches = result.batch + 1;
        if (result.foundMatches.length > 0) {
          allMatches.push(...result.foundMatches);
        }
        // Stop if we found matches for all hashes
        const matchedHashes = new Set(allMatches.map(m => m.hash));
        if (matchedHashes.size === targetHashesLocal.length) {
          break;
        }
      }

      // Record end time
      const endDate = new Date();
      const endPerf = performance.now();
      const durationMs = endPerf - startPerf;
      const durationSeconds = durationMs / 1000;
      const hashesPerSecond = durationSeconds > 0 ? Math.round(totalVariantsCounter.count / durationSeconds) : 0;

      // Hide progress bar and reset buttons
      progressContainer.classList.remove('active');
      resultEl.classList.remove('processing');
      crackButton.disabled = false;
      crackButton.textContent = 'Start Cracking';
      stopButton.disabled = true;

      // Display results
      let resultText = '';
      if (isStopping) {
        resultText = 'Cracking stopped by user.\n';
        resultEl.style.color = '#ff6b6b';
      } else if (allMatches.length > 0) {
        resultText = 'Matches found:\n';
        for (let match of allMatches) {
          resultText += `Hash ${match.hash}: Password: ${match.password}\n`;
        }
        resultEl.style.color = '#00ff88';
      } else {
        resultText = 'No matches found for any hash.\n';
        resultEl.style.color = '#ff6b6b';
      }
      // Report hashes with no matches
      const matchedHashes = new Set(allMatches.map(m => m.hash));
      for (let hash of targetHashStringsLocal) {
        if (!matchedHashes.has(hash)) {
          resultText += `Hash ${hash}: No match found.\n`;
        }
      }
      resultEl.textContent = resultText;

      // Display timing info with hashes per second
      if (!isStopping) {
        const timingHtml = `
Started: ${startDate.toLocaleString()}
Ended: ${endDate.toLocaleString()}
Time taken: ${formatDuration(durationMs)}
Hashes per second: ${hashesPerSecond.toLocaleString()}
Total variants tested: ${totalVariantsCounter.count.toLocaleString()}
        `;
        timingInfo.innerHTML = timingHtml;
        timingInfo.style.display = 'block';
      }
    };
  </script>
</body>
</html>
